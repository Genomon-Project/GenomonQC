#! /usr/bin/python
"""

Convert tab deliniated text to VCF.


"""

import sys
import os
from datetime import datetime
import argparse
import pysam

from ANNOVAR import AnnoCSVOut
from ANNOVAR import AnnoTSVOut
from ANNOVAR import AnnoIn

#
#
#
VCF_file_header1 = \
"""##fileformat=VCFv4.2
##fileDate={date}
##source=ToVCF.py
##reference={ref_fasta}
##phasing=none
"""

VCF_file_header2 = \
"""##INFO=<ID=DP,Number=1,Type=Integer,Description="Total Depth">
##FILTER=<ID=PASS, Description="Passed variant FILTERs">
##FILTER=<ID=MISSING,Description="undeclared filter tag">
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO
"""

VCF_file_header2_simple = \
"""#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO
"""

VCF_file_header2_full = \
"""##FILTER=<ID=LowQual,Description="QUAL < 50.0">
##INFO=<ID=AC,Number=.,Type=Integer,Description="Allele count in genotypes, for each ALT allele, in the same order as listed">
##INFO=<ID=AF,Number=.,Type=Float,Description="Allele Frequency, for each ALT allele, in the same order as listed">
##INFO=<ID=AN,Number=1,Type=Integer,Description="Total number of alleles in called genotypes">
##INFO=<ID=DB,Number=0,Type=Flag,Description="dbSNP Membership">
##INFO=<ID=DP,Number=1,Type=Integer,Description="Total Depth">
##INFO=<ID=DS,Number=0,Type=Flag,Description="Were any of the samples downsampled?">
##INFO=<ID=Dels,Number=1,Type=Float,Description="Fraction of Reads Containing Spanning Deletions">
##INFO=<ID=HRun,Number=1,Type=Integer,Description="Largest Contiguous Homopolymer Run of Variant Allele In Either Direction">
##INFO=<ID=HaplotypeScore,Number=1,Type=Float,Description="Consistency of the site with two (and only two) segregating haplotypes">
##INFO=<ID=MQ,Number=1,Type=Float,Description="RMS Mapping Quality">
##INFO=<ID=MQ0,Number=1,Type=Integer,Description="Total Mapping Quality Zero Reads">
##INFO=<ID=QD,Number=1,Type=Float,Description="Variant Confidence/Quality by Depth">
##INFO=<ID=SB,Number=1,Type=Float,Description="Strand Bias">
##INFO=<ID=VQSLOD,Number=1,Type=Float,Description="log10-scaled probability of variant being true under the trained gaussian mixture model">
##FORMAT=<ID=AD,Number=.,Type=Integer,Description="Allelic depths for the ref and alt alleles in the order listed">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Read Depth (only filtered reads used for calling)">
##FORMAT=<ID=GQ,Number=1,Type=Float,Description="Genotype Quality">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=PL,Number=3,Type=Float,Description="Normalized, Phred-scaled likelihoods for AA,AB,BB genotypes where A=ref and B=alt; not applicable if site is not biallelic">
#CHROM  POS ID      REF ALT QUAL    FILTER  INFO    FORMAT
"""
# INFO example
# AC=1;AF=0.50;AN=2;DP=315;Dels=0.00;HRun=2;HaplotypeScore=15.11;MQ=91.05;MQ0=15;QD=16.61;SB=-1533.02;VQSLOD=-1.5473
#
# FORMAT example
# GT:AD:DP:GQ:PL   0/1:173,141:282:99:255,0,255
#
# Annotation tag in VCF     Meaning
# AC,AF,AN    See the Technical Documentation for Chromosome Counts.
# DB  If present, then the variant is in dbSNP.
# DP  See the Technical Documentation for Coverage.
# DS  Were any of the samples downsampled because of too much coverage?
# Dels    See the Technical Documentation for SpanningDeletions.
# MQ and MQ0  See the Technical Documentation for RMS Mapping Quality and Mapping Quality Zero.
# BaseQualityRankSumTest  See the Technical Documentation for Base Quality Rank Sum Test.
# MappingQualityRankSumTest   See the Technical Documentation for Mapping Quality Rank Sum Test.
# ReadPosRankSumTest  See the Technical Documentation for Read Position Rank Sum Test.
# HRun    See the Technical Documentation for Homopolymer Run.
# HaplotypeScore  See the Technical Documentation for Haplotype Score.
# QD  See the Technical Documentation for Qual By Depth.
# VQSLOD  Only present when using Variant quality score recalibration. Log odds ratio of being a true variant versus being false under the trained gaussian mixture model.
# FS  See the Technical Documentation for Fisher Strand
# SB  How much evidence is there for Strand Bias (the variation being seen on only the forward or only the reverse strand) in the reads? Higher SB values denote more bias (and therefore are more likely to indicate false positive calls).

#
# Subroutines
#
myself = None
now = datetime.now()

def PrintHeader():
    global myself
    print '#' * 84
    print '# Summary'
    print '# Generated by %(my)s' % { 'my': myself }
    print '# %(y)d.%(mo)d.%(d)d.%(h)d:%(mi)d' % { 'y': now.year, 'mo': now.month, 'd': now.day, 'h': now.hour, 'mi': now.minute }
    print '#' * 84 + ''




#
# Main
#
def main():
    #
    # Argument parse
    #
    global myself

    argvs = sys.argv
    myself = argvs[ 0 ]
    argc = len(argvs)

    parser = argparse.ArgumentParser( description = "Make VCF file from Genomon output." )
    parser.add_argument( '-c', '--csv_annovar_output', help = "Input file",             type = str )
    parser.add_argument( '-t', '--tsv_annovar_output', help = "Input file",             type = str )
    parser.add_argument( '-a', '--annovar_input',      help = "Input file",             type = str )
    parser.add_argument( '-o', '--output_vcf',         help = "Output VCF file",        type = str )
    parser.add_argument( '-r', '--ref_fasta',          help = "Reference FASTA file",   type = str )
    parser.add_argument( '-s', '--simple',             help = "Simple output",          action='store_true', default=False )

    if argc < 2:
        print parser.print_help();
        sys.exit(1)
    
    arg = parser.parse_args()

    #
    # Print header
    #
    PrintHeader()


    #
    # 1. CHROM - chromosome:  An identifier from the reference genome or an angle-bracketed ID String ("<ID>")
    #   pointing to a contig in the assembly file (cf.  the ##assembly line in the header).  All entries for a specific
    #   CHROM should form a contiguous block within the VCF file.  The colon symbol (:)  must be absent from all
    #   chromosome names to avoid parsing errors when dealing with breakends.  (String, no white-space permitted,
    #   Required).
    #
    # 2.  POS - position:  The reference position, with the 1st base having position 1. Positions are sorted numerically,
    #   in increasing order, within each reference sequence CHROM. It is permitted to have multiple records with the
    #   same POS. Telomeres are indicated by using positions 0 or N+1, where N is the length of the corresponding
    #   chromosome or contig.  (Integer, Required)
    #
    # 3.  ID - identifier:  Semi-colon separated list of unique identifiers where available.
    #   If this is a dbSNP variant it is encouraged to use the rs number(s). No identifier should be present
    #   in more than one data record.  If there is no identifier available, then the missing value should be used.
    #   (String, no white-space or semi-colons permitted)
    #
    # 4.  REF - reference base(s):  Each base must be one of A,C,G,T,N (case insensitive).  Multiple bases are permitted.
    #   The  value  in  the  POS field  refers  to  the  position  of  the  first  base  in  the  String.
    #   For  simple  insertions  and deletions in which either the REF or one of the ALT alleles would otherwise be
    #   null/empty, the REF and ALT Strings must include the base before the event (which must be reected in the POS
    #   field),  unless the event
    #   occurs at position 1 on the contig in which case it must include the base after the event; this padding base is
    #   not required (although it is permitted) for e.g.  complex substitutions or other events where all alleles have at
    #   least one base represented in their Strings.  If any of the ALT alleles is a symbolic allele (an angle-bracketed
    #   ID String ( <ID>") then the padding base is required and POS denotes the coordinate of the base preceding
    #   the polymorphism.  Tools processing VCF files are not required to preserve case in the allele Strings.  (String,
    #   Required).
    #
    # 5.  ALT - alternate base(s):  Comma separated list of alternate non-reference alleles called on at least one of the
    #   samples.  Options are base Strings made up of the bases A,C,G,T,N,*, (case insensitive) or an angle-bracketed
    #   ID String ("<ID>") or a breakend replacement string as described in the section on breakends.  The `*' allele
    #   is reserved to indicate that the allele is missing due to a upstream deletion.  If there are no alternative alleles,
    #   then the missing value should be used.  Tools processing VCF files are not required to preserve case in the
    #   allele String, except for IDs, which are case sensitive.  (String; no whitespace, commas, or angle-brackets are
    #   permitted in the ID String itself)
    #
    # 6.  QUAL - quality:  Phred-scaled quality score for the assertion made in ALT.
    #   i.e. -10log10 prob(call in ALT is wrong).
    #   If ALT is '.' (no variant) then this is -10log10  prob(variant), and if ALT is not `.'  this is -10log10
    #   prob(no variant). If unknown, the missing value should be specified. (Numeric)
    #
    # 7.  FILTER - filter status: PASS if this position has passed all filters, i.e.  a call is made at this position.
    #   Otherwise, if the site has not passed all filters, a semicolon-separated list of codes for filters that fail.
    #   e.g.  \q10;s50" might
    #   indicate that at this site the quality is below 10 and the number of samples with data is below 50% of the total
    #   number of samples.  `0' is reserved and should not be used as a filter String.  If filters have not been applied,
    #   then this field should be set to the missing value.  (String, no white-space or semi-colon ) #
    # 8.  INFO - additional information:  (String, no white-space, semi-colons, or equals-signs permitted;  commas are
    #   permitted only as delimiters for lists of values) INFO fields are encoded as a semicolon-separated series of short
    #   keys with optional values in the format: < key > = < data > [,data].  Arbitrary keys are permitted, although the
    #   following sub-fields are reserved (albeit optional):
    #
    #       AA : ancestral allele
    #       AC : allele count in genotypes, for each ALT allele, in the same order as listed
    #       AF : allele frequency for each ALT allele in the same order as listed: use this when estimated from primary
    #           data, not called genotypes
    #       AN : total number of alleles in called genotypes
    #       BQ : RMS base quality at this position
    #       CIGAR : cigar string describing how to align an alternate allele to the reference allele
    #       DB : dbSNP membership
    #       DP : combined depth across samples, e.g.  DP=154
    #       END : end position of the variant described in this record (for use with symbolic alleles)
    #       H2 :  membership in hapmap2
    #       H3 :  membership in hapmap3
    #       MQ : RMS mapping quality, e.g.  MQ=52
    #       MQ0 :  Number of MAPQ == 0 reads covering this record
    #       NS : Number of samples with data
    #       SB : strand bias at this position
    #       SOMATIC : indicates that the record is a somatic mutation, for cancer genomics
    #       VALIDATED : validated by follow-up experiment
    #       1000G : membership in 1000 Genomes
    #
    #   The exact format of each INFO sub-field should be specified in the meta-information (as described above).  Example
    #   for an INFO field:  DP=154;MQ=52;H2.  Keys without corresponding values are allowed in order to indicate group
    #   membership (e.g.  H2 indicates the SNP is found in HapMap 2).  It is not necessary to list all the properties that
    #   a site does NOT have, by e.g.  H2=0.  See below for additional reserved INFO sub-fields used to encode structural
    #   variants.
    #

    try:
        if arg.ref_fasta:
            ref_fasta = pysam.FastaFile( arg.ref_fasta )
        else:
            ref_fasta = None

        if arg.csv_annovar_output:
            InFile = AnnoCSVOut( arg.csv_annovar_output )
        elif arg.tsv_annovar_output:
            InFile = AnnoTSVOut( arg.tsv_annovar_output )
        elif arg.annovar_input: 
            InFile = AnnoIn( arg.annovar_input )

        today = "{0:%Y%m%d}".format( now )

        vcf_file = open( arg.output_vcf, 'w')
        lines1 = VCF_file_header1.format( date = today, ref_fasta = arg.ref_fasta )
        if arg.simple:
            lines2 = VCF_file_header2_simple
        else:
            lines2 = VCF_file_header2

        vcf_file.writelines( lines1 + lines2 )

        for chr, start, end, id, ref, alt, quality, filter, info, format in InFile.read():
            # CHROM POS ID REF ALT QUAL FILTER INFO
            if ref_fasta:
                if ref == '-':
                    ref_tmp = ref_fasta.fetch( chr, int( start ) + 1, int( start ) + 2 )
                    # insertion
                    ref = ref_tmp
                    alt = ref_tmp + alt
                elif alt == '-':
                    ref_tmp = ref_fasta.fetch( chr, int( start ), int( start ) + 1 )
                    start = int( start) - 1
                    # deletion
                    alt = ref_tmp
                    ref = ref + ref_tmp

            if arg.simple:
                record = (  chr[ 3: ],
                            str( start ),
                            '.',
                            ref.upper(),
                            alt.upper(),
                            '.',
                            '.',
                            '.'
                        )
            else:
                record = (  chr[ 3: ],
                            str( start ),
                            str( id ),
                            ref.upper(),
                            alt.upper(),
                            str( quality ),
                            filter,
                            info
                        )
            vcf_file.write( '\t'.join( record ) + '\n' )


        vcf_file.close()
        InFile.close()

    except Exception as e:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        print( ("{0}: {1}:{2}".format( exc_type, fname, exc_tb.tb_lineno) ) )
        raise

if __name__ == "__main__":
    main()

